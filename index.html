import React, { useRef, useState, useEffect } from "react";

// House Plan Drawer — Single-file React component
// - Tailwind CSS is used for styling (class names present, no import required here)
// - Default export a React component so it can be previewed
// - Basic features: grid, wall drawing (click-drag), place doors/windows, select/move, delete, export SVG & JSON
// - Coordinate system: units are meters, 1 meter = scale pixels (adjustable)

// Notes for embedding / running
// - Drop this component into a create-react-app / Vite project with Tailwind configured
// - Or paste into CodeSandbox (React + Tailwind) to preview

const TOOL = {
  SELECT: "select",
  WALL: "wall",
  DOOR: "door",
  WINDOW: "window",
  ERASE: "erase",
};

function uid(prefix = "id") {
  return `${prefix}_${Math.random().toString(36).slice(2, 9)}`;
}

export default function HousePlanDrawer() {
  // canvas refs
  const svgRef = useRef(null);
  const containerRef = useRef(null);

  // state: drawing
  const [tool, setTool] = useState(TOOL.WALL);
  const [gridSize, setGridSize] = useState(0.5); // meters
  const [scale, setScale] = useState(100); // pixels per meter
  const [snap, setSnap] = useState(true);
  const [showGrid, setShowGrid] = useState(true);

  // model: walls, openings
  const [walls, setWalls] = useState([]); // {id,x1,y1,x2,y2}
  const [openings, setOpenings] = useState([]); // {id,type,x,y,angle,length}

  // interaction
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentLine, setCurrentLine] = useState(null); // {x1,y1,x2,y2}
  const [selectedId, setSelectedId] = useState(null);

  // pan / zoom
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const panStartRef = useRef(null);

  // helpers: world<->screen
  function worldToScreen(pt) {
    return {
      x: pt.x * scale + pan.x,
      y: pt.y * scale + pan.y,
    };
  }
  function screenToWorld(pt) {
    return {
      x: (pt.x - pan.x) / scale,
      y: (pt.y - pan.y) / scale,
    };
  }

  // snapping
  function snapToGrid(pt) {
    if (!snap) return pt;
    const gx = gridSize;
    return {
      x: Math.round(pt.x / gx) * gx,
      y: Math.round(pt.y / gx) * gx,
    };
  }

  // mouse handlers
  function handlePointerDown(e) {
    if (e.button !== 0) return; // left only
    const rect = svgRef.current.getBoundingClientRect();
    const screen = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    const world = snapToGrid(screenToWorld(screen));

    if (tool === TOOL.WALL) {
      setIsDrawing(true);
      setCurrentLine({ x1: world.x, y1: world.y, x2: world.x, y2: world.y });
    } else if (tool === TOOL.SELECT) {
      // select nearest wall/opening
      const pick = pickEntity(world);
      setSelectedId(pick ? pick.id : null);
    } else if (tool === TOOL.ERASE) {
      const pick = pickEntity(world);
      if (pick) {
        if (pick.type === "wall") setWalls((w) => w.filter((i) => i.id !== pick.id));
        else setOpenings((o) => o.filter((i) => i.id !== pick.id));
      }
    } else if (tool === TOOL.DOOR || tool === TOOL.WINDOW) {
      // place opening attached to nearest wall
      const nearest = findNearestWall(world);
      if (nearest) {
        const { wall, proj } = nearest;
        const angle = Math.atan2(wall.y2 - wall.y1, wall.x2 - wall.x1);
        const id = uid('op');
        setOpenings((prev) => [
          ...prev,
          { id, type: tool, x: proj.x, y: proj.y, angle, length: 0.9 },
        ]);
      }
    }
  }

  function handlePointerMove(e) {
    const rect = svgRef.current.getBoundingClientRect();
    const screen = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    const world = snapToGrid(screenToWorld(screen));

    if (isDrawing && currentLine) {
      setCurrentLine((c) => ({ ...c, x2: world.x, y2: world.y }));
    }

    if (isPanning && panStartRef.current) {
      const dx = e.clientX - panStartRef.current.x;
      const dy = e.clientY - panStartRef.current.y;
      setPan({ x: panStartRef.current.pan.x + dx, y: panStartRef.current.pan.y + dy });
    }
  }

  function handlePointerUp(e) {
    if (isDrawing && currentLine) {
      // finalize wall if length > small threshold
      const dx = currentLine.x2 - currentLine.x1;
      const dy = currentLine.y2 - currentLine.y1;
      const len = Math.hypot(dx, dy);
      if (len > 0.05) {
        const newWall = { id: uid('w'), ...currentLine };
        setWalls((prev) => [...prev, newWall]);
      }
      setCurrentLine(null);
      setIsDrawing(false);
    }
    setIsPanning(false);
    panStartRef.current = null;
  }

  // pick entity (very simple: nearest distance to a wall segment or opening)
  function pickEntity(world) {
    const PICK_DIST = 0.15; // meters
    // check openings
    for (let o of openings) {
      const d = Math.hypot(world.x - o.x, world.y - o.y);
      if (d <= PICK_DIST) return { id: o.id, type: "opening", kind: o.type };
    }
    // check walls
    for (let w of walls) {
      const dist = pointToSegmentDistance({ x: world.x, y: world.y }, w);
      if (dist <= PICK_DIST) return { id: w.id, type: "wall" };
    }
    return null;
  }

  function pointToSegmentDistance(p, s) {
    const x = p.x;
    const y = p.y;
    const x1 = s.x1;
    const y1 = s.y1;
    const x2 = s.x2;
    const y2 = s.y2;
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;

    let xx, yy;

    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    const dx = x - xx;
    const dy = y - yy;
    return Math.hypot(dx, dy);
  }

  function findNearestWall(pt) {
    let best = null;
    let bestd = Infinity;
    for (let w of walls) {
      // project pt onto segment
      const proj = projectPointToSegment(pt, w);
      const d = Math.hypot(pt.x - proj.x, pt.y - proj.y);
      if (d < bestd) {
        bestd = d;
        best = { wall: w, proj };
      }
    }
    if (best && bestd < 0.5) return best; // within 0.5m
    return null;
  }

  function projectPointToSegment(p, s) {
    const x1 = s.x1, y1 = s.y1, x2 = s.x2, y2 = s.y2;
    const dx = x2 - x1, dy = y2 - y1;
    const l2 = dx * dx + dy * dy;
    if (l2 === 0) return { x: x1, y: y1 };
    const t = ((p.x - x1) * dx + (p.y - y1) * dy) / l2;
    const tt = Math.max(0, Math.min(1, t));
    return { x: x1 + tt * dx, y: y1 + tt * dy };
  }

  // export
  function exportSVG() {
    const svgEl = svgRef.current.cloneNode(true);
    // remove UI-only elements (like selection handlers)
    // serialize
    const serializer = new XMLSerializer();
    const str = serializer.serializeToString(svgEl);
    const blob = new Blob([str], { type: "image/svg+xml" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "house-plan.svg";
    a.click();
    URL.revokeObjectURL(url);
  }

  function exportJSON() {
    const obj = { walls, openings, gridSize, scale };
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "house-plan.json";
    a.click();
    URL.revokeObjectURL(url);
  }

  function importJSON(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if (data.walls) setWalls(data.walls);
        if (data.openings) setOpenings(data.openings);
        if (data.gridSize) setGridSize(data.gridSize);
        if (data.scale) setScale(data.scale);
      } catch (err) {
        alert("Invalid JSON");
      }
    };
    reader.readAsText(file);
  }

  // simple rendering helpers
  function renderGrid(width, height) {
    if (!showGrid) return null;
    const spacing = gridSize * scale;
    const lines = [];
    // determine visible bounds in world coords
    const leftWorld = screenToWorld({ x: 0, y: 0 });
    const rightWorld = screenToWorld({ x: width, y: height });
    const minX = Math.floor(Math.min(leftWorld.x, rightWorld.x) / gridSize) * gridSize;
    const maxX = Math.ceil(Math.max(leftWorld.x, rightWorld.x) / gridSize) * gridSize;
    const minY = Math.floor(Math.min(leftWorld.y, rightWorld.y) / gridSize) * gridSize;
    const maxY = Math.ceil(Math.max(leftWorld.y, rightWorld.y) / gridSize) * gridSize;

    for (let x = minX; x <= maxX; x += gridSize) {
      const sx = worldToScreen({ x, y: 0 }).x;
      lines.push(<line key={`vx${x}`} x1={sx} y1={0} x2={sx} y2={height} stroke="#e6e6e6" strokeWidth={1} />);
    }
    for (let y = minY; y <= maxY; y += gridSize) {
      const sy = worldToScreen({ x: 0, y }).y;
      lines.push(<line key={`hy${y}`} x1={0} y1={sy} x2={width} y2={sy} stroke="#e6e6e6" strokeWidth={1} />);
    }
    return <g>{lines}</g>;
  }

  // viewbox size
  const [viewSize, setViewSize] = useState({ w: 1200, h: 700 });
  useEffect(() => {
    function onResize() {
      if (!containerRef.current) return;
      const rect = containerRef.current.getBoundingClientRect();
      setViewSize({ w: rect.width, h: rect.height });
    }
    onResize();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  // small UI: toolbar + canvas
  return (
    <div className="flex h-full w-full gap-2" style={{ fontFamily: 'Inter, sans-serif' }}>
      <aside className="w-64 p-3 bg-white border-r shadow-sm">
        <h3 className="text-lg font-semibold mb-2">House Plan Drawer</h3>
        <div className="flex flex-col gap-2">
          <div className="grid grid-cols-2 gap-2">
            {Object.values(TOOL).map((t) => (
              <button
                key={t}
                onClick={() => setTool(t)}
                className={`p-2 rounded-md border ${tool === t ? 'bg-blue-600 text-white' : 'bg-gray-50'}`}
              >
                {t}
              </button>
            ))}
          </div>

          <div className="mt-3">
            <label className="block text-sm">Grid size (m)</label>
            <input
              type="number"
              step="0.1"
              value={gridSize}
              onChange={(e) => setGridSize(parseFloat(e.target.value) || 0.1)}
              className="w-full p-1 border rounded"
            />
            <label className="block text-sm mt-2">Scale (px / m)</label>
            <input
              type="number"
              step="10"
              value={scale}
              onChange={(e) => setScale(parseFloat(e.target.value) || 50)}
              className="w-full p-1 border rounded"
            />
            <div className="flex items-center gap-2 mt-2">
              <input checked={snap} onChange={(e) => setSnap(e.target.checked)} type="checkbox" id="snap" />
              <label htmlFor="snap">Snap</label>
            </div>
            <div className="flex items-center gap-2 mt-2">
              <input checked={showGrid} onChange={(e) => setShowGrid(e.target.checked)} type="checkbox" id="grid" />
              <label htmlFor="grid">Show grid</label>
            </div>
          </div>

          <div className="mt-3 flex flex-col gap-2">
            <button onClick={exportSVG} className="p-2 rounded border bg-green-600 text-white">Export SVG</button>
            <button onClick={exportJSON} className="p-2 rounded border bg-indigo-600 text-white">Export JSON</button>
            <label className="p-2 rounded border bg-gray-50 text-sm text-center cursor-pointer">
              Import JSON
              <input onChange={importJSON} type="file" accept="application/json" className="hidden" />
            </label>
            <button
              onClick={() => {
                // clear
                if (confirm('Clear drawing?')) {
                  setWalls([]);
                  setOpenings([]);
                }
              }}
              className="p-2 rounded border bg-red-500 text-white"
            >
              Clear
            </button>
          </div>

          <div className="mt-4 text-xs text-gray-600">
            Tip: Use Wall tool to click-drag to draw. Use Door/Window to snap an opening to the nearest wall.
          </div>
        </div>
      </aside>

      <main ref={containerRef} className="flex-1 relative bg-gray-100">
        <svg
          ref={svgRef}
          width="100%"
          height="100%"
          viewBox={`0 0 ${viewSize.w} ${viewSize.h}`}
          onMouseDown={(e) => {
            // middle mouse for pan
            if (e.button === 1) {
              setIsPanning(true);
              panStartRef.current = { x: e.clientX, y: e.clientY, pan: { ...pan } };
            }
            handlePointerDown(e);
          }}
          onMouseMove={handlePointerMove}
          onMouseUp={handlePointerUp}
          onMouseLeave={handlePointerUp}
          style={{ touchAction: 'none', userSelect: 'none' }}
        >
          <rect x={0} y={0} width={viewSize.w} height={viewSize.h} fill="#fff" />

          {/* grid */}
          {renderGrid(viewSize.w, viewSize.h)}

          {/* walls */}
          <g>
            {walls.map((w) => {
              const p1 = worldToScreen({ x: w.x1, y: w.y1 });
              const p2 = worldToScreen({ x: w.x2, y: w.y2 });
              const isSelected = selectedId === w.id;
              return (
                <g key={w.id}>
                  <line
                    x1={p1.x}
                    y1={p1.y}
                    x2={p2.x}
                    y2={p2.y}
                    stroke={isSelected ? '#ff6600' : '#333'}
                    strokeWidth={6}
                    strokeLinecap="round"
                    opacity={0.95}
                  />
                  {/* center dimension label */}
                  <text x={(p1.x + p2.x) / 2} y={(p1.y + p2.y) / 2 - 8} fontSize={12} textAnchor="middle">
                    {((Math.hypot(w.x2 - w.x1, w.y2 - w.y1)) .toFixed(2))} m
                  </text>
                </g>
              );
            })}

            {/* current drawing line */}
            {currentLine && (
              <line
                x1={worldToScreen({ x: currentLine.x1, y: currentLine.y1 }).x}
                y1={worldToScreen({ x: currentLine.x1, y: currentLine.y1 }).y}
                x2={worldToScreen({ x: currentLine.x2, y: currentLine.y2 }).x}
                y2={worldToScreen({ x: currentLine.x2, y: currentLine.y2 }).y}
                stroke="#0066ff"
                strokeWidth={4}
                strokeDasharray="6 4"
              />
            )}
          </g>

          {/* openings */}
          <g>
            {openings.map((o) => {
              const p = worldToScreen({ x: o.x, y: o.y });
              const angle = o.angle;
              const len = o.length * scale;
              const x2 = p.x + Math.cos(angle) * len;
              const y2 = p.y + Math.sin(angle) * len;
              return (
                <g key={o.id}>
                  {/* opening as thinner line with marker */}
                  <line x1={p.x} y1={p.y} x2={x2} y2={y2} stroke="#00aaff" strokeWidth={4} strokeLinecap="round" />
                  <text x={p.x} y={p.y - 10} fontSize={12} textAnchor="middle">{o.type}</text>
                </g>
              );
            })}
          </g>

          {/* overlays: small controls */}
        </svg>

        {/* bottom HUD */}
        <div className="absolute left-4 bottom-4 bg-white p-2 rounded shadow text-xs">
          <div>Tool: <strong>{tool}</strong></div>
          <div>Scale: <strong>{scale}px/m</strong> • Grid: <strong>{gridSize} m</strong></div>
          <div>Entities: <strong>{walls.length} walls</strong>, <strong>{openings.length} openings</strong></div>
        </div>
      </main>
    </div>
  );
}
